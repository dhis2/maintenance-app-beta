/* GENERATED BY https://github.com/Birkbjo/dhis2-open-api-ts */
import {
    IdentifiableObject,
    GistPager,
    Pager,
    DataElement,
    Filter,
    BaseIdentifiableObject,
} from './'
// import { CategoryCombo, DataElement } from "../generated";

export type ModelCollection<T = IdentifiableObject> = Array<T>
type ModelReference = IdentifiableObject | ModelCollection

export type ModelCollectionResponse<
    T extends IdentifiableObject = IdentifiableObject,
    PagedListName extends string = 'result'
> = PagedResponse<T, PagedListName>

export type PagedResponse<T, PagedListName extends string = 'result'> = {
    [K in PagedListName]: T[]
} & { pager: Pager }

type BaseGist<T> = IdentifiableObject & {
    apiEndpoints: GistApiEndpoints<T>
}

export type GistApiEndpoints<T> = {
    // filter keys that are references and map them to string
    [P in keyof T as T[P] extends ModelReference ? P : never]: string
}
/**
 * A utility type that takes a Model (eg. DataElement)
 * and returns the gist-api representation of that model
 */
export type GistModel<T> = BaseGist<T> & {
    [P in keyof T]: T[P] extends ModelReference
        ? T[P] extends ModelCollection
            ? number // map array-references to number (gist shows total in collection)
            : string // map references to a string (gist shows id)
        : T[P]
}

export type GistModelCollection<T> = GistModel<T>[]

// a modelcollection with the keyprop
// need it's own type because the name of the list is based on resource or pagedListName query-param
export type GistModelCollectionPart<
    T extends IdentifiableObject,
    PagedListName extends string = 'result'
> = {
    [K in PagedListName]: GistModel<T>[]
}

export type GistPagedResponse = {
    pager: GistPager
}

export type GistCollectionResponse<
    T extends IdentifiableObject = IdentifiableObject,
    PagedListName extends string = 'result'
> = GistPagedResponse & GistModelCollectionPart<T, PagedListName>

export type GistObjectResponse<
    T extends IdentifiableObject = IdentifiableObject
> = GistModel<T>

export type GistResponse<
    T extends IdentifiableObject = IdentifiableObject,
    R extends string = string
> = GistCollectionResponse<T, R> | GistObjectResponse<T>

/**
 * Utility type that takes a ReferenceKey of a GistResponse and returns a GistResponse of the referenced key
 *
 * This can be useful when you want to get the referenced object from a GistResponse
 *
 * Example:
 *
 * type DataElementGistResponse = GistCollectionResponse<DataElement, 'dataElements'>;
 *
 * type CatComboGistResponse = GetGistResponseForReference<'categoryCombo', DataElementGistResponse>;
 *
 * TODO: cleanup, split up and use utility types
 */
export type GetGistResponseForReference<
    ReferenceKey extends string,
    GR
> = GR extends GistCollectionResponse<infer RootGistModel, infer R> //extends GistResponse<IdentifiableObject, string>> = string
    ? ReferenceKey extends keyof RootGistModel
        ? RootGistModel[ReferenceKey] extends ModelCollection<
              infer ReferencedModel extends IdentifiableObject
          >
            ? GistCollectionResponse<ReferencedModel, ReferenceKey>
            : RootGistModel[ReferenceKey] extends IdentifiableObject
            ? GistObjectResponse<RootGistModel[ReferenceKey]>
            : unknown
        : never
    : GR extends GistObjectResponse<infer GistModel>
    ? ReferenceKey extends keyof GistModel
        ? GistModel[ReferenceKey] extends ModelCollection<
              infer ReferencedModel extends IdentifiableObject
          >
            ? GistCollectionResponse<ReferencedModel, ReferenceKey>
            : GistModel[ReferenceKey] extends IdentifiableObject
            ? GistObjectResponse<GistModel[ReferenceKey]>
            : unknown
        : never
    : never

export type GistParams = {
    absoluteUrls?: boolean
    auto?: 'XL' | 'L' | 'M' | 'S' | 'XS'
    describe?: boolean
    fields?: string
    filter?: string
    headless?: boolean
    inverse?: boolean
    locale?: string
    order?: string
    page?: number
    pageSize?: number
    pageListName?: string
    references?: boolean
    rootJunction?: 'AND' | 'OR'
    total?: boolean
    translate?: boolean
}

// utility type GistModel can be used like this:
// type DataElementGist = GistModel<
//     Pick<DataElement, "id" | "code" | "categoryCombo" | "legendSets">
// >;

/**
 * A utility type that takes a Model (eg. DataElement)
 * and returns a type with the properties that are references
 * Note that in case of collections, the type of the property will be the type of the items in the collection
 * 
 * Eg. GetReferencedModels<DataElement> will return:
 *  {
*   categoryCombo: CategoryCombo;
    commentOptionSet: OptionSet;
    createdBy: User;
    dataElementGroups: DataElementGroup; // note that this is not a collection
    lastUpdatedBy: User;
    legendSet: LegendSet;
    legendSets: LegendSet; // note that this is not a collection
    optionSet: OptionSet;
    user: User;
}
 */
export type GetReferencedModels<T extends IdentifiableObject> = {
    [P in keyof T as T[P] extends ModelReference
        ? P
        : never]: T[P] extends ModelCollection ? T[P][number] : T[P]
}

/**
 * Constructs a type by picking the properties of T that are of type V
 */
export type PickValue<T, V> = {
    [P in keyof T as T[P] extends V ? P : never]: T[P]
}

export type PickReferenceProperties<T extends IdentifiableObject> = PickValue<
    T,
    ModelReference
>

// helper type to get an union of all the values in a type
type Values<T> = T[keyof T]

//helper type to get an union of all the referenced models
export type GetReferencedModelsUnion<T extends IdentifiableObject> = Values<
    GetReferencedModels<T>
>

// helper type for PickInModelReferences
// takes a type and returns the "true" type of the model.
// eg if it's a collection, return the type of the members
// if its not a modeltype, return never
type GetModelType<T> = T extends ModelReference
    ? T extends Array<infer U>
        ? U
        : T
    : never

// helper type for PickInReferences
// Wraps the type in ModelCollection if FullModel extends ModelReferenceCollection
type MaybeModelCollection<
    ModelType,
    FullModel extends ModelReference
> = FullModel extends ModelCollection ? ModelCollection<ModelType> : ModelType

type DataElementWithFilteredRefs = PickInModelReferences<
    { id: 'string'; cat: { id: string } },
    'id'
>
/**
 * Utility type that picks the properties (RefProps) from the referenced models (RefModelsUnion) in Model
 *
 * RefModelsUnion can also be omitted to pick the same field from all modelreferences.
 * This can be useful when you want to pick the "id" | "displayName" from all references, for example.
 *
 * @example Pick id, displayName for all references
 * type DataElementWithFilteredRefs = PickInModelReferences<DataElement, "id" | "displayName">
 *
 * @example Pick, id, name, categories for categoryCombo-reference
 * type DataElementWithFilteredRefs = PickInModelReferences<DataElement, "id" | "name" | "categories", DataElement["categoryCombo"]>
 */
export type PickInModelReferences<
    Model extends IdentifiableObject,
    RefProps extends keyof RefModelsUnion | string,
    // we need union because RefProps above cannot extend keyof Model[P][number]
    RefModelsUnion extends GetReferencedModelsUnion<Model> = GetReferencedModelsUnion<Model>
> = {
    [P in keyof Model]: Model[P] extends ModelReference
        ? // GetModelType is needed to be able to use RefModelsUnion to filter which properties the type should appy to
          // because modelcollections would not extend RefModelsUnion otherwise
          GetModelType<Model[P]> extends RefModelsUnion
            ? // first extract the correct model-type from the union of referenced models
              // then pick the keys from that type
              // then wrap in modelcollection if Model[P] is a collection
              MaybeModelCollection<
                  Pick<
                      Extract<RefModelsUnion, GetModelType<Model[P]>>,
                      RefProps & keyof RefModelsUnion
                  >,
                  Model[P]
              >
            : // if not reference, do nothing
              Model[P]
        : Model[P]
}

type Last<T extends any[]> = T extends [...infer _, infer L] ? L : never
type RemoveLast<T extends any[]> = T extends [...infer R, any] ? R : never
type RemoveSpaces<S extends string> = S extends `${infer T} ${infer U}`
    ? RemoveSpaces<`${T}${U}`>
    : S

type SplitRestAndLast<T extends any[]> = T extends [...infer Head, infer Tail]
    ? [Head, Tail]
    : never
/* 
  Helper Type to split a nested field string into components.
  NOTE: This only supports one level of nesting, and will also not split after any nested brackets.
  However, this is a helper, and full recursion support of field-filters 
  is supported in cooperation with ModelFromFields below.
 Split<'categoryOptions,id,name,sharing[public,owner]', ','>
 becomes: ["categoryOptions", "id", "name", "sharing[public,owner]"]
*/
type RecursiveSplitFieldFilter<
    S extends string,
    D extends string = ','
> = string extends S
    ? string[]
    : S extends ''
    ? []
    : S extends `${infer T}${D}${infer U}`
    ? U extends `${infer UHead}[${infer NestedFields}]`
        ? // if last part (U) is a nested field eg. categoryCombo[id,name]
          // we dont want to split inside of brackets - because that would split the nested field
          // eg. "categoryOptions,id,name,sharing[public,owner]" would become ['categoryOptions', 'id', 'name','sharing[public', 'owner]']
          // so we first recurse without last part (sharing) and split the parts before the brackets.
          // then we need to add the last element (sharing) back before the brackets.
          // Since there's no way to "store" the result of the recursion, we need to do it twice
          //   [T, ...RecursiveSplitFieldFilter<U>]
          [
              T,
              ...RemoveLast<RecursiveSplitFieldFilter<UHead, D>>,
              `${Last<RecursiveSplitFieldFilter<UHead, D>>}[${NestedFields}]`
          ]
        : //   [
          //       T,
          //       ...(RecursiveSplitFieldFilter<UHead, D> extends [ // Extends here is used to "store" the result of the recursion
          //           ...infer Head extends any[],
          //           infer NestedRoot extends string // NestedRoot is eg. sharing in id,name,sharing[id]
          //       ]
          //           ? [...Head, `${NestedRoot}[${NestedFields}]`]
          //           : never),
          //         //   ...RecursiveSplitFieldFilter<Rest>
          //   ]
          // [T, `${RootModel}[${NestedFields}]`]
          [T, ...RecursiveSplitFieldFilter<U, D>]
    : [S]

type SplitFieldFilter<
    S extends string,
    D extends string = ','
> = RecursiveSplitFieldFilter<RemoveSpaces<S>, D>

type Te =
    SplitFieldFilter<'categoryOptions,id,name,sharing[public,owner[id]],categoryCombo[id]'>

// helper to ensure that a key is a key of an object, if not return never
// mainly to prevent super deep ternaries
type EnsureKeyOf<Key extends string, Obj> = Key extends keyof Obj ? Key : never

// gets the model, if in an array, return the model in the array
type GetModel<T> = T extends Array<infer U> ? U : T

type MaybeCollection<Model, FullModel> = FullModel extends Array<infer U>
    ? Model[]
    : Model

type PickIdentifiableFields<TModel> = Pick<
    TModel,
    ('id' | 'code' | 'name' | 'created' | 'lastUpdated' | 'lastUpdatedBy') &
        keyof TModel
>

type FilterPresetsMap<
    TModel extends IdentifiableObject,
    S extends string = 'id'
> = {
    '*': PickInModelReferences<TModel, 'id'>
    ':identifiable': PickIdentifiableFields<TModel>
}

type TD = FilterPresetsMap<DataElement>[':identifiable'] &
    FilterPresetsMap<DataElement>['*']
const t = {} as TD

// type EnsureValidField<TKey extends string, TModel> = EnsureKeyOf<TKey, TModel> extends
// type GetShortcutFields<T>
export type PickModelFields<
    Model extends BaseIdentifiableObject,
    Fields extends keyof Model & string // = keyof Model & string // = [...keyof (T & string)]
> = {
    [Field in Fields as Field extends `${infer Nested}[${string}]` // Field field is nested
        ? EnsureKeyOf<Nested, Model> // ensure that Nested is a key of T, and return the key (eg. categoryCombo from categoryCombo[id,name])
        : EnsureKeyOf<
              Field,
              Model
          >]: Field extends `${infer Nested}[${infer Rest}]`
        ? Nested extends keyof Model // needed to do T[Nested] below
            ? // if its a valid nested field, recurse down the object
              // wrap in collection, if the original field was a collection
              MaybeCollection<
                  PickModelFields<
                      GetModel<Model[Nested]>, // get the model from the array, if its an array
                      SplitFieldFilter<Rest>[number] // split the rest of the field-filter into ['id', 'name']
                  >,
                  Model[Nested]
              >
            : unknown // if Nested is not keyOf model, return unknown
        : Field extends keyof Model
        ? Model[Field] // if its not a nested field, return the property as is
        : unknown // not a key of Model, return unknown
}

const fieldFilters = [
    'id',
    'code',
    'categoryCombo[id,displayName]',
    'optionSet[id,displayName,valueType, user[user[id]]]',
    'attributeValues[value,attribute[id,displayName,valueType,optionSet[id,displayName]]]',
] as const

type FilteredDataElement = PickModelFields<
    DataElement,
    'id' | ''
    // (typeof fieldFilters)[number]
>
// const de = {} as FilteredDataElement
// de.categoryCombo

// de.attributeValues.map(av => av.attribute.optionSet.)
// const oDe = {} as DataElement
